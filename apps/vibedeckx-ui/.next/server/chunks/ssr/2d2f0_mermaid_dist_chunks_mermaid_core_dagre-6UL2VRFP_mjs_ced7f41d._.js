module.exports=[21970,a=>{"use strict";var b=a.i(85655);a.i(92115);var c=a.i(10473),d=a.i(38700);a.i(1540),a.i(64332),a.i(35757);var e=a.i(90742),f=a.i(2697);a.i(58736);var g=a.i(35660),h=a.i(63701),i=a.i(29997),i=i,j=a.i(48450);a.i(1e4);var k=a.i(92655);function l(a){var b,c,d={options:{directed:a.isDirected(),multigraph:a.isMultigraph(),compound:a.isCompound()},nodes:(b=a,j.map(b.nodes(),function(a){var c=b.node(a),d=b.parent(a),e={v:a};return h.isUndefined(c)||(e.value=c),h.isUndefined(d)||(e.parent=d),e})),edges:(c=a,j.map(c.edges(),function(a){var b=c.edge(a),d={v:a.v,w:a.w};return h.isUndefined(a.name)||(d.name=a.name),h.isUndefined(b)||(d.value=b),d}))};return h.isUndefined(a.graph())||(d.value=i.default(a.graph())),d}a.i(53415);var m=new Map,n=new Map,o=new Map,p=(0,f.__name)(()=>{n.clear(),o.clear(),m.clear()},"clear"),q=(0,f.__name)((a,b)=>{let c=n.get(b)||[];return f.log.trace("In isDescendant",b," ",a," = ",c.includes(a)),c.includes(a)},"isDescendant"),r=(0,f.__name)((a,b)=>{let c=n.get(b)||[];return f.log.info("Descendants of ",b," is ",c),f.log.info("Edge is ",a),a.v!==b&&a.w!==b&&(c.includes(a.v)||q(a.v,b)||q(a.w,b)||c.includes(a.w))},"edgeInCluster"),s=(0,f.__name)((a,b,c,d)=>{f.log.warn("Copying children of ",a,"root",d,"data",b.node(a),d);let e=b.children(a)||[];a!==d&&e.push(a),f.log.warn("Copying (nodes) clusterId",a,"nodes",e),e.forEach(e=>{if(b.children(e).length>0)s(e,b,c,d);else{let g=b.node(e);f.log.info("cp ",e," to ",d," with parent ",a),c.setNode(e,g),d!==b.parent(e)&&(f.log.warn("Setting parent",e,b.parent(e)),c.setParent(e,b.parent(e))),a!==d&&e!==a?(f.log.debug("Setting parent",e,a),c.setParent(e,a)):(f.log.info("In copy ",a,"root",d,"data",b.node(a),d),f.log.debug("Not Setting parent for node=",e,"cluster!==rootId",a!==d,"node!==clusterId",e!==a));let h=b.edges(e);f.log.debug("Copying Edges",h),h.forEach(e=>{f.log.info("Edge",e);let g=b.edge(e.v,e.w,e.name);f.log.info("Edge data",g,d);try{r(e,d)?(f.log.info("Copying as ",e.v,e.w,g,e.name),c.setEdge(e.v,e.w,g,e.name),f.log.info("newGraph edges ",c.edges(),c.edge(c.edges()[0]))):f.log.info("Skipping copy of edge ",e.v,"-->",e.w," rootId: ",d," clusterId:",a)}catch(a){f.log.error(a)}})}f.log.debug("Removing node",e),b.removeNode(e)})},"copy"),t=(0,f.__name)((a,b)=>{let c=b.children(a),d=[...c];for(let e of c)o.set(e,a),d=[...d,...t(e,b)];return d},"extractDescendants"),u=(0,f.__name)((a,b,c)=>{let d=a.edges().filter(a=>a.v===b||a.w===b),e=a.edges().filter(a=>a.v===c||a.w===c),f=d.map(a=>({v:a.v===b?c:a.v,w:a.w===b?b:a.w})),g=e.map(a=>({v:a.v,w:a.w}));return f.filter(a=>g.some(b=>a.v===b.v&&a.w===b.w))},"findCommonEdges"),v=(0,f.__name)((a,b,c)=>{let d,e=b.children(a);if(f.log.trace("Searching children of id ",a,e),e.length<1)return a;for(let a of e){let e=v(a,b,c),f=u(b,c,e);if(e)if(!(f.length>0))return e;else d=e}return d},"findNonClusterChild"),w=(0,f.__name)(a=>m.has(a)&&m.get(a).externalConnections&&m.has(a)?m.get(a).id:a,"getAnchorId"),x=(0,f.__name)((a,b)=>{if(!a||b>10)return void f.log.debug("Opting out, no graph ");for(let b of(f.log.debug("Opting in, graph "),a.nodes().forEach(function(b){a.children(b).length>0&&(f.log.warn("Cluster identified",b," Replacement id in edges: ",v(b,a,b)),n.set(b,t(b,a)),m.set(b,{id:v(b,a,b),clusterData:a.node(b)}))}),a.nodes().forEach(function(b){let c=a.children(b),d=a.edges();c.length>0?(f.log.debug("Cluster identified",b,n),d.forEach(a=>{q(a.v,b)^q(a.w,b)&&(f.log.warn("Edge: ",a," leaves cluster ",b),f.log.warn("Descendants of XXX ",b,": ",n.get(b)),m.get(b).externalConnections=!0)})):f.log.debug("Not a cluster ",b,n)}),m.keys())){let c=m.get(b).id,d=a.parent(c);d!==b&&m.has(d)&&!m.get(d).externalConnections&&(m.get(b).id=d)}a.edges().forEach(function(b){let c=a.edge(b);f.log.warn("Edge "+b.v+" -> "+b.w+": "+JSON.stringify(b)),f.log.warn("Edge "+b.v+" -> "+b.w+": "+JSON.stringify(a.edge(b)));let d=b.v,e=b.w;if(f.log.warn("Fix XXX",m,"ids:",b.v,b.w,"Translating: ",m.get(b.v)," --- ",m.get(b.w)),m.get(b.v)||m.get(b.w)){if(f.log.warn("Fixing and trying - removing XXX",b.v,b.w,b.name),d=w(b.v),e=w(b.w),a.removeEdge(b.v,b.w,b.name),d!==b.v){let e=a.parent(d);m.get(e).externalConnections=!0,c.fromCluster=b.v}if(e!==b.w){let d=a.parent(e);m.get(d).externalConnections=!0,c.toCluster=b.w}f.log.warn("Fix Replacing with XXX",d,e,b.name),a.setEdge(d,e,c,b.name)}}),f.log.warn("Adjusted Graph",l(a)),y(a,0),f.log.trace(m)},"adjustClustersAndEdges"),y=(0,f.__name)((a,b)=>{if(f.log.warn("extractor - ",b,l(a),a.children("D")),b>10)return void f.log.error("Bailing out");let c=a.nodes(),d=!1;for(let b of c){let c=a.children(b);d=d||c.length>0}if(!d)return void f.log.debug("Done, no node has children",a.nodes());for(let d of(f.log.debug("Nodes = ",c,b),c))if(f.log.debug("Extracting node",d,m,m.has(d)&&!m.get(d).externalConnections,!a.parent(d),a.node(d),a.children("D")," Depth ",b),m.has(d))if(!m.get(d).externalConnections&&a.children(d)&&a.children(d).length>0){f.log.warn("Cluster without external connections, without a parent and with children",d,b);let c="TB"===a.graph().rankdir?"LR":"TB";m.get(d)?.clusterData?.dir&&(c=m.get(d).clusterData.dir,f.log.warn("Fixing dir",m.get(d).clusterData.dir,c));let e=new k.Graph({multigraph:!0,compound:!0}).setGraph({rankdir:c,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});f.log.warn("Old graph before copy",l(a)),s(d,a,e,d),a.setNode(d,{clusterNode:!0,id:d,clusterData:m.get(d).clusterData,label:m.get(d).label,graph:e}),f.log.warn("New graph after copy node: (",d,")",l(e)),f.log.debug("Old graph after copy",l(a))}else f.log.warn("Cluster ** ",d," **not meeting the criteria !externalConnections:",!m.get(d).externalConnections," no parent: ",!a.parent(d)," children ",a.children(d)&&a.children(d).length>0,a.children("D"),b),f.log.debug(m);else f.log.debug("Not a cluster",d,b);for(let d of(c=a.nodes(),f.log.warn("New list of nodes",c),c)){let c=a.node(d);f.log.warn(" Now next level",d,c),c?.clusterNode&&y(c.graph,b+1)}},"extractor"),z=(0,f.__name)((a,b)=>{if(0===b.length)return[];let c=Object.assign([],b);return b.forEach(b=>{let d=a.children(b),e=z(a,d);c=[...c,...e]}),c},"sorter"),A=(0,f.__name)(a=>z(a,a.children()),"sortNodesByHierarchy"),B=(0,f.__name)(async(a,e,h,i,j,k)=>{f.log.warn("Graph in recursive render:XAX",l(e),j);let n=e.graph().rankdir;f.log.trace("Dir in recursive render - dir:",n);let o=a.insert("g").attr("class","root");e.nodes()?f.log.info("Recursive render XXX",e.nodes()):f.log.info("No nodes found for",e),e.edges().length>0&&f.log.info("Recursive edges",e.edge(e.edges()[0]));let p=o.insert("g").attr("class","clusters"),q=o.insert("g").attr("class","edgePaths"),r=o.insert("g").attr("class","edgeLabels"),s=o.insert("g").attr("class","nodes");await Promise.all(e.nodes().map(async function(a){let b=e.node(a);if(void 0!==j){let b=JSON.parse(JSON.stringify(j.clusterData));f.log.trace("Setting data for parent cluster XXX\n Node.id = ",a,"\n data=",b.height,"\nParent cluster",j.height),e.setNode(j.id,b),e.parent(a)||(f.log.trace("Setting parent",a,j.id),e.setParent(a,j.id,b))}if(f.log.info("(Insert) Node XXX"+a+": "+JSON.stringify(e.node(a))),b?.clusterNode){f.log.info("Cluster identified XBX",a,b.width,e.node(a));let{ranksep:d,nodesep:g}=e.graph();b.graph.setGraph({...b.graph.graph(),ranksep:d+25,nodesep:g});let j=await B(s,b.graph,h,i,e.node(a),k),l=j.elem;(0,c.updateNodeBounds)(b,l),b.diff=j.diff||0,f.log.info("New compound node after recursive render XAX",a,"width",b.width,"height",b.height),(0,c.setNodeElem)(l,b)}else e.children(a).length>0?(f.log.trace("Cluster - the non recursive path XBX",a,b.id,b,b.width,"Graph:",e),f.log.trace(v(b.id,e)),m.set(b.id,{id:v(b.id,e),node:b})):(f.log.trace("Node - the non recursive path XAX",a,s,e.node(a),n),await (0,c.insertNode)(s,e.node(a),{config:k,dir:n}))}));let t=(0,f.__name)(async()=>{let a=e.edges().map(async function(a){let c=e.edge(a.v,a.w,a.name);f.log.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(a)),f.log.info("Edge "+a.v+" -> "+a.w+": ",a," ",JSON.stringify(e.edge(a))),f.log.info("Fix",m,"ids:",a.v,a.w,"Translating: ",m.get(a.v),m.get(a.w)),await (0,b.insertEdgeLabel)(r,c)});await Promise.all(a)},"processEdges");await t(),f.log.info("Graph before layout:",JSON.stringify(l(e))),f.log.info("############################################# XXX"),f.log.info("###                Layout                 ### XXX"),f.log.info("############################################# XXX"),(0,g.layout)(e),f.log.info("Graph after layout:",JSON.stringify(l(e)));let u=0,{subGraphTitleTotalMargin:w}=(0,d.getSubGraphTitleMargins)(k);return await Promise.all(A(e).map(async function(a){let b=e.node(a);if(f.log.info("Position XBX => "+a+": ("+b.x,","+b.y,") width: ",b.width," height: ",b.height),b?.clusterNode)b.y+=w,f.log.info("A tainted cluster node XBX1",a,b.id,b.width,b.height,b.x,b.y,e.parent(a)),m.get(b.id).node=b,(0,c.positionNode)(b);else if(e.children(a).length>0){f.log.info("A pure cluster node XBX1",a,b.id,b.x,b.y,b.width,b.height,e.parent(a)),b.height+=w,e.node(b.parentId);let d=b?.padding/2||0,g=b?.labelBBox?.height||0;f.log.debug("OffsetY",g-d||0,"labelHeight",g,"halfPadding",d),await (0,c.insertCluster)(p,b),m.get(b.id).node=b}else{let a=e.node(b.parentId);b.y+=w/2,f.log.info("A regular node XBX1 - using the padding",b.id,"parent",b.parentId,b.width,b.height,b.x,b.y,"offsetY",b.offsetY,"parent",a,a?.offsetY,b),(0,c.positionNode)(b)}})),e.edges().forEach(function(a){let c=e.edge(a);f.log.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(c),c),c.points.forEach(a=>a.y+=w/2);let d=e.node(a.v);var g=e.node(a.w);let j=(0,b.insertEdge)(q,c,m,h,d,g,i);(0,b.positionEdgeLabel)(c,j)}),e.nodes().forEach(function(a){let b=e.node(a);f.log.info(a,b.type,b.diff),b.isGroup&&(u=b.diff)}),f.log.warn("Returning from recursive render XAX",o,u),{elem:o,diff:u}},"recursiveRender"),C=(0,f.__name)(async(a,d)=>{let g=new k.Graph({multigraph:!0,compound:!0}).setGraph({rankdir:a.direction,nodesep:a.config?.nodeSpacing||a.config?.flowchart?.nodeSpacing||a.nodeSpacing,ranksep:a.config?.rankSpacing||a.config?.flowchart?.rankSpacing||a.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),h=d.select("g");(0,b.markers_default)(h,a.markers,a.type,a.diagramId),(0,c.clear2)(),(0,b.clear)(),(0,c.clear)(),p(),a.nodes.forEach(a=>{g.setNode(a.id,{...a}),a.parentId&&g.setParent(a.id,a.parentId)}),f.log.debug("Edges:",a.edges),a.edges.forEach(a=>{if(a.start===a.end){let b=a.start,c=b+"---"+b+"---1",d=b+"---"+b+"---2",e=g.node(b);g.setNode(c,{domId:c,id:c,parentId:e.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),g.setParent(c,e.parentId),g.setNode(d,{domId:d,id:d,parentId:e.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),g.setParent(d,e.parentId);let f=structuredClone(a),h=structuredClone(a),i=structuredClone(a);f.label="",f.arrowTypeEnd="none",f.id=b+"-cyclic-special-1",h.arrowTypeStart="none",h.arrowTypeEnd="none",h.id=b+"-cyclic-special-mid",i.label="",e.isGroup&&(f.fromCluster=b,i.toCluster=b),i.id=b+"-cyclic-special-2",i.arrowTypeStart="none",g.setEdge(b,c,f,b+"-cyclic-special-0"),g.setEdge(c,d,h,b+"-cyclic-special-1"),g.setEdge(d,b,i,b+"-cyc<lic-special-2")}else g.setEdge(a.start,a.end,{...a},a.id)}),f.log.warn("Graph at first:",JSON.stringify(l(g))),x(g),f.log.warn("Graph after XAX:",JSON.stringify(l(g)));let i=(0,e.getConfig2)();await B(h,g,a.type,a.diagramId,void 0,i)},"render");a.s(["render",()=>C],21970)}];

//# sourceMappingURL=2d2f0_mermaid_dist_chunks_mermaid_core_dagre-6UL2VRFP_mjs_ced7f41d._.js.map